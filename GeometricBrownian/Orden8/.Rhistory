RK42 = -(M[2,1]*(X[1,i]+delta*RK31)+M[2,2]*(X[1,i]+delta*RK32))
X[1,i+1] = X[1,i] + (1/6)*delta*(RK11+2*RK21+2*RK31+RK41)
X[2,i+1] = X[2,i] + (1/6)*delta*(RK12+2*RK22+2*RK32+RK42)
}
return(X)
}
OU_2dEULER=function(x0,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=x0
for(i in 1:n)
{
X[1,i+1]=X[1,i]+(-(M[1,1]*X[1,i]+M[1,2]*X[2,i]))*delta
X[2,i+1]=X[2,i]+(-(M[2,1]*X[1,i]+M[2,2]*X[2,i]))*delta
}
return(X)
}
#integral con respecto a Xms
Integrate2d_Xms=function(path,Xms)
{
npoints=length(path)
integral = matrix(0,2,npoints)
integral1=numeric(npoints)
integral2=numeric(npoints)
for( i in 2:npoints)
{
integral1[i]=(Xms[1,i]-Xms[1,i-1])*(path[i-1]+path[i])/2.0
integral2[i]=(Xms[2,i]-Xms[2,i-1])*(path[i-1]+path[i])/2.0
}
integral1=cumsum(integral1)
integral2=cumsum(integral2)
integral[1,] <-integral1
integral[2,] <-integral2
return(integral)
}
#calcula senos
fsenos=function(n,TiempoC)
{
TL<-length(TiempoC)
TF=tail(TiempoC,1)
senos<-mat.or.vec(n,TL)
for(i in 1:n){
senos[i,]=sin(i*pi*TiempoC/TF)
}
return(senos)
}
#calcula cosenos
fcosenos=function(n,TiempoC)
{
TL<-length(TiempoC)
TF=tail(TiempoC,1)
cosenos<-mat.or.vec(n,TL)
for(i in 1:n){
cosenos[i,]=cos(i*pi*TiempoC/TF)
}
return(cosenos)
}
library("plot3D")
#System conf
n<-1000
nb <-500
t0 <-0
tf <-1
delta <- (tf-t0)/n
Tiempo <-seq(t0, tf, length.out = n+1)
TL<-length(Tiempo)
#initial conditions
x01 <- 0
x02 <- 0
M11 <-1.5
M12 <-1
M21 <-1
M22 <-1.5
sigma11 <-1
sigma12 <-1
sigma21 <-1
sigma22 <-1
theta <- c(1,1)
x0 <- c(x01,x02)
M <- matrix(c(M11,M12,M21,M22),nrow = 2,ncol = 2)
Sigma <- matrix(c(sigma11,sigma12,sigma21,sigma22),nrow = 2,ncol = 2)
M_Y1=mat.or.vec(10,TL)
M_Y2=mat.or.vec(10,TL)
M2_Y1=mat.or.vec(10,TL)
M2_Y2=mat.or.vec(10,TL)
X_0<- OU_2dRK(x0,n)
Y_0<-matrix(0,2,n+1)
int1 <- matrix(0,2,n+1)
int1=cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_0),0)
for(i in 1:TL)
{
Y_0[1,i]= x0[1]+(theta[1]-x0[1])*Tiempo[i]/tf+int1[1,i]
Y_0[2,i]= x0[2]+(theta[2]-x0[2])*Tiempo[i]/tf+int1[2,i]
}
#### propagator for |m|=1
Y1x1=NULL
Y1x2=NULL
Y1_aux=NULL
Y2x1=NULL
Y2x2=NULL
Y2_aux=NULL
for(i in 1:nb){
X_1<-XmOU1_2dRK(i,n)
X_2<-XmOU2_2dRK(i,n)
Y1_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_1),0)
Y1x1 <-rbind(Y1x1,Y1_aux[1,])
Y1x2 <-rbind(Y1x2,Y1_aux[2,])
Y2_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_2),0)
Y2x1 <-rbind(Y2x1,Y2_aux[1,])
Y2x2 <-rbind(Y2x2,Y2_aux[2,])
}
for (k in 1:10){
print(k)
X1is=rnorm(nb,0,1)
X2is=rnorm(nb,0,1)#fXis(nb,TiempoC)
M_Y1[k,]=apply(Y1x1*X1is[1]*X2is,2,sum)+apply(Y2x1*X2is*X1is[2],2,sum)+Y_0[1,]
M_Y2[k,]=apply(Y1x2*X1is[1]*X2is,2,sum)+apply(Y2x2*X1is[2]*X2is,2,sum)+Y_0[2,]
#M_Y[k,]=Y_0
}
#return(Tiempo,M_Y1)
par(mfrow=c(2,2))
plot(Tiempo,M_Y1[1,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[1,],type = 'l',xlab="t",ylab="Y1_t")
plot(Tiempo,M_Y1[2,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[2,],type = 'l',xlab="t",ylab="Y2_t")
plot(Tiempo,Y1x1)
View(Y1x1)
View(Y1x1)
plot(Tiempo,Y1x1[1,])
plot(Tiempo,Y1x1[2,])
plot(Tiempo,Y1x1[3,])
plot(Tiempo,Y1x1[4,])
plot(Tiempo,Y1x1[5,])
M[1,2]
X[2,i]
X=matrix(0,2,n+1)
X[,1]=c(0,0)
M[1,1]*X[1,i]
M[1,2]*X[2,i]
-(M[1,1]*X[1,i]+M[1,2]*X[2,i])
plot(sqrt(2/tf)*sin(2*pi*Tiempo[i]/tf))
plot(tiempo,sqrt(2/tf)*sin(2*pi*Tiempo/tf))
Tiempo
plot(Riempo,sqrt(2/tf)*sin(2*pi*Tiempo/tf))
plot(Tiempo,sqrt(2/tf)*sin(2*pi*Tiempo/tf))
plot(Tiempo,sqrt(2/tf)*sin(499*pi*Tiempo/tf))
plot(Tiempo,sqrt(2/tf)*sin(498*pi*Tiempo/tf))
plot(Tiempo,sqrt(2/tf)*sin(498*pi*Tiempo[1:100]/tf))
plot(Tiempo[1:100],sqrt(2/tf)*sin(498*pi*Tiempo[1:100]/tf))
sqrt(2/tf)*sin(498*pi*Tiempo[1:100]/tf)
plot(Tiempo[1:100],sqrt(2/tf)*sin(498*pi*Tiempo[1:100]/tf),type = "l")
plot(Tiempo[1:100],sqrt(2/tf)*sin(499*pi*Tiempo[1:100]/tf),type = "l")
plot(Tiempo,sqrt(2/tf)*sin(499*pi*Tiempo/tf),type = "l")
plot(Tiempo[490:510],sqrt(2/tf)*sin(499*pi*Tiempo[490:510]/tf),type = "l")
plot(Tiempo,sqrt(2/tf)*sin(499*pi*Tiempo/tf),type = "l")
plot(Tiempo,sqrt(2/tf)*sin(500*pi*Tiempo/tf),type = "l")
plot(Tiempo,sqrt(2/tf)*sin(501*pi*Tiempo/tf),type = "l")
plot(Tiempo,sqrt(2/tf)*sin(502*pi*Tiempo/tf),type = "l")
plot(Tiempo,sqrt(2/tf)*sin(503*pi*Tiempo/tf),type = "l")
####################
####################
XmOU1_2dRK=function(j,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=c(0,0)
for(i in 1:n)
{
RK11 = -(M[1,1]*X[1,i]+M[1,2]*X[2,i]) + sigma11*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf)+sigma12*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK12 = -(M[2,1]*X[1,i]+M[2,2]*X[2,i]) + sigma21*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf)+sigma22*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK21 = -(M[1,1]*(X[1,i]+0.5*delta*RK11)+M[1,2]*(X[2,i]+0.5*delta*RK12)) + sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK22 = -(M[2,1]*(X[1,i]+0.5*delta*RK11)+M[2,2]*(X[2,i]+0.5*delta*RK12)) + sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK31 = -(M[1,1]*(X[1,i]+0.5*delta*RK21)+M[1,2]*(X[2,i]+0.5*delta*RK22)) + sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK32 = -(M[2,1]*(X[1,i]+0.5*delta*RK21)+M[2,2]*(X[2,i]+0.5*delta*RK22)) + sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK41 = -(M[1,1]*(X[1,i]+delta*RK31)+M[1,2]*(X[2,i]+delta*RK32)) +sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
RK42 = -(M[2,1]*(X[1,i]+delta*RK31)+M[2,2]*(X[1,i]+delta*RK32)) +sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
X[1,i+1] = X[1,i] + (1/6)*delta*(RK11+2*RK21+2*RK31+RK41)
X[2,i+1] = X[2,i] + (1/6)*delta*(RK12+2*RK22+2*RK32+RK42)
}
return(X)
}
library("plot3D")
#System conf
n<-1000
nb <-500
t0 <-0
tf <-1
delta <- (tf-t0)/n
Tiempo <-seq(t0, tf, length.out = n+1)
TL<-length(Tiempo)
#initial conditions
x01 <- 0
x02 <- 0
M11 <-1.5
M12 <-1
M21 <-1
M22 <-1.5
sigma11 <-1
sigma12 <-1
sigma21 <-1
sigma22 <-1
theta <- c(1,1)
x0 <- c(x01,x02)
M <- matrix(c(M11,M12,M21,M22),nrow = 2,ncol = 2)
Sigma <- matrix(c(sigma11,sigma12,sigma21,sigma22),nrow = 2,ncol = 2)
M_Y1=mat.or.vec(10,TL)
M_Y2=mat.or.vec(10,TL)
M2_Y1=mat.or.vec(10,TL)
M2_Y2=mat.or.vec(10,TL)
X_0<- OU_2dRK(x0,n)
Y_0<-matrix(0,2,n+1)
int1 <- matrix(0,2,n+1)
int1=cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_0),0)
for(i in 1:TL)
{
Y_0[1,i]= x0[1]+(theta[1]-x0[1])*Tiempo[i]/tf+int1[1,i]
Y_0[2,i]= x0[2]+(theta[2]-x0[2])*Tiempo[i]/tf+int1[2,i]
}
#### propagator for |m|=1
Y1x1=NULL
Y1x2=NULL
Y1_aux=NULL
Y2x1=NULL
Y2x2=NULL
Y2_aux=NULL
for(i in 1:nb){
X_1<-XmOU1_2dRK(i,n)
X_2<-XmOU2_2dRK(i,n)
Y1_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_1),0)
Y1x1 <-rbind(Y1x1,Y1_aux[1,])
Y1x2 <-rbind(Y1x2,Y1_aux[2,])
Y2_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_2),0)
Y2x1 <-rbind(Y2x1,Y2_aux[1,])
Y2x2 <-rbind(Y2x2,Y2_aux[2,])
}
for (k in 1:10){
print(k)
X1is=rnorm(nb,0,1)
X2is=rnorm(nb,0,1)#fXis(nb,TiempoC)
M_Y1[k,]=apply(Y1x1*X1is[1]*X2is,2,sum)+apply(Y2x1*X2is*X1is[2],2,sum)+Y_0[1,]
M_Y2[k,]=apply(Y1x2*X1is[1]*X2is,2,sum)+apply(Y2x2*X1is[2]*X2is,2,sum)+Y_0[2,]
#M_Y[k,]=Y_0
}
#return(Tiempo,M_Y1)
par(mfrow=c(2,2))
plot(Tiempo,M_Y1[1,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[1,],type = 'l',xlab="t",ylab="Y1_t")
plot(Tiempo,M_Y1[2,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[2,],type = 'l',xlab="t",ylab="Y2_t")
plot(Tiempo,Y1x1[5,])
plot(Tiempo,Y1x1[1,])
plot(Tiempo,Y_0)
plot(Tiempo,Y_0][1,])
plot(Tiempo,Y_0[1,])
plot(Tiempo,Y_0[2,])
####################
####################
XmOU1_2dRK=function(j,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=c(0,0)
for(i in 1:n)
{
RK11 = -(M[1,1]*X[1,i]+M[1,2]*X[2,i]) + sigma11*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf)+sigma12*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK12 = -(M[2,1]*X[1,i]+M[2,2]*X[2,i]) + sigma21*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf)+sigma22*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK21 = -(M[1,1]*(X[1,i]+0.5*delta*RK11)+M[1,2]*(X[2,i]+0.5*delta*RK12)) + sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK22 = -(M[2,1]*(X[1,i]+0.5*delta*RK11)+M[2,2]*(X[2,i]+0.5*delta*RK12)) + sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK31 = -(M[1,1]*(X[1,i]+0.5*delta*RK21)+M[1,2]*(X[2,i]+0.5*delta*RK22)) + sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK32 = -(M[2,1]*(X[1,i]+0.5*delta*RK21)+M[2,2]*(X[2,i]+0.5*delta*RK22)) + sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK41 = -(M[1,1]*(X[1,i]+delta*RK31)+M[1,2]*(X[2,i]+delta*RK32)) +sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
RK42 = -(M[2,1]*(X[1,i]+delta*RK31)+M[2,2]*(X[1,i]+delta*RK32)) +sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
X[1,i+1] = X[1,i] + (1/6)*delta*(RK11+2*RK21+2*RK31+RK41)
X[2,i+1] = X[2,i] + (1/6)*delta*(RK12+2*RK22+2*RK32+RK42)
}
return(X)
}
XmOU2_2dRK=function(j,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=c(0,0)
for(i in 1:n)
{
RK11 = -(M[1,1]*X[1,i]+M[1,2]*X[2,i]) + sigma11*sqrt(2/tf)*sin(2*pi*Tiempo[i]/tf)+sigma12*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK12 = -(M[2,1]*X[1,i]+M[2,2]*X[2,i]) + sigma21*sqrt(2/tf)*sin(2*pi*Tiempo[i]/tf)+sigma22*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK21 = -(M[1,1]*(X[1,i]+0.5*delta*RK11)+M[1,2]*(X[2,i]+0.5*delta*RK12)) + sigma11*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK22 = -(M[2,1]*(X[1,i]+0.5*delta*RK11)+M[2,2]*(X[2,i]+0.5*delta*RK12)) + sigma21*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK31 = -(M[1,1]*(X[1,i]+0.5*delta*RK21)+M[1,2]*(X[2,i]+0.5*delta*RK22)) + sigma11*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK32 = -(M[2,1]*(X[1,i]+0.5*delta*RK21)+M[2,2]*(X[2,i]+0.5*delta*RK22)) + sigma21*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK41 = -(M[1,1]*(X[1,i]+delta*RK31)+M[1,2]*(X[2,i]+delta*RK32)) +sigma11*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
RK42 = -(M[2,1]*(X[1,i]+delta*RK31)+M[2,2]*(X[1,i]+delta*RK32)) +sigma21*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
X[1,i+1] = X[1,i] + (1/6)*delta*(RK11+2*RK21+2*RK31+RK41)
X[2,i+1] = X[2,i] + (1/6)*delta*(RK12+2*RK22+2*RK32+RK42)
}
return(X)
}
XmOU1_2dEULER=function(j,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=c(0,0)
for(i in 1:n)
{
X[1,i+1]=X[1,i]+(-(M[1,1]*X[1,i]+M[1,2]*X[2,i]) + (sigma11+sigma12)*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf))*delta
X[2,i+1]=X[2,i]+(-(M[2,1]*X[1,i]+M[2,2]*X[2,i]) + (sigma21+sigma22)*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf))*delta
}
return(X)
}
library("plot3D")
#System conf
n<-1000
nb <-500
t0 <-0
tf <-1
delta <- (tf-t0)/n
Tiempo <-seq(t0, tf, length.out = n+1)
TL<-length(Tiempo)
#initial conditions
x01 <- 0
x02 <- 0
M11 <-1.5
M12 <-1
M21 <-1
M22 <-1.5
sigma11 <-1
sigma12 <-1
sigma21 <-1
sigma22 <-1
theta <- c(1,1)
x0 <- c(x01,x02)
M <- matrix(c(M11,M12,M21,M22),nrow = 2,ncol = 2)
Sigma <- matrix(c(sigma11,sigma12,sigma21,sigma22),nrow = 2,ncol = 2)
M_Y1=mat.or.vec(10,TL)
M_Y2=mat.or.vec(10,TL)
M2_Y1=mat.or.vec(10,TL)
M2_Y2=mat.or.vec(10,TL)
X_0<- OU_2dRK(x0,n)
Y_0<-matrix(0,2,n+1)
int1 <- matrix(0,2,n+1)
int1=cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_0),0)
for(i in 1:TL)
{
Y_0[1,i]= x0[1]+(theta[1]-x0[1])*Tiempo[i]/tf+int1[1,i]
Y_0[2,i]= x0[2]+(theta[2]-x0[2])*Tiempo[i]/tf+int1[2,i]
}
#### propagator for |m|=1
Y1x1=NULL
Y1x2=NULL
Y1_aux=NULL
Y2x1=NULL
Y2x2=NULL
Y2_aux=NULL
for(i in 1:nb){
X_1<-XmOU1_2dRK(i,n)
X_2<-XmOU2_2dRK(i,n)
Y1_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_1),0)
Y1x1 <-rbind(Y1x1,Y1_aux[1,])
Y1x2 <-rbind(Y1x2,Y1_aux[2,])
Y2_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_2),0)
Y2x1 <-rbind(Y2x1,Y2_aux[1,])
Y2x2 <-rbind(Y2x2,Y2_aux[2,])
}
for (k in 1:10){
print(k)
X1is=rnorm(nb,0,1)
X2is=rnorm(nb,0,1)#fXis(nb,TiempoC)
M_Y1[k,]=apply(Y1x1*X1is[1]*X2is,2,sum)+apply(Y2x1*X2is*X1is[2],2,sum)+Y_0[1,]
M_Y2[k,]=apply(Y1x2*X1is[1]*X2is,2,sum)+apply(Y2x2*X1is[2]*X2is,2,sum)+Y_0[2,]
#M_Y[k,]=Y_0
}
#return(Tiempo,M_Y1)
par(mfrow=c(2,2))
plot(Tiempo,M_Y1[1,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[1,],type = 'l',xlab="t",ylab="Y1_t")
plot(Tiempo,M_Y1[2,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[2,],type = 'l',xlab="t",ylab="Y2_t")
plot(Tiempo,Y1x1[1,])
plot(Tiempo,Y1x1[2,])
plot(Tiempo,Y1x1[3,])
plot(Tiempo,Y1x1[4,])
plot(Tiempo,Y1x1[100,])
plot(Tiempo,Y1x1[99,])
plot(Tiempo,Y1x1[50,])
Tiempo[TL]-Tiempo[1:(TL-1)]
1/(tf-Tiempo[-TL])
X[,1]=c(0,0)
View(X)
View(X)
plot(X0)
plot(X_0)
X_0
plot(Tiempo,X_0)
plot(Tiempo,X_0[1,])
plot(Tiempo,X_0[2,])
install.packages("languageserver")
setwd("D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/GeometricBrownian")
setwd("D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/GeometricBrownian/Orden8")
####### My main
source('Milstein_for_GBM.R')
####### My main
source('Milstein_codes.R')
source('HermiteFunction.R')
source('BridgeChaosFunction.R')
source('IntegralItoTrapecio.R')
source('Vikngos_Geometric.R')
library(ggplot2)
############
####### My main
source('Milstein_codes.R')
source('HermiteFunction.R')
source('BridgeChaosFunction.R')
source('IntegralItoTrapecio.R')
source('Vikngos_Geometric.R')
library(ggplot2)
############
############
sigma=0.3
alpha=0.2
delta=1/1000
n=1000
nb=1000
a=0.2
b=0.3
##### number of bridges
M=1000
###### Read propagator D:\DiffusionBridgesWienerExpantion\DiffusionBridgesWienerExpantion\GeometricBrownian\New_propagator
Xms=t(as.matrix(read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/GeometricBrownian/New_propagator/Propagator_order8_int0.2_alpha0.5_sigma1_MB1000.csv'))[,-1])
Lp = dim(Xms)[[1]]
TF=delta*n
TiempoC<-seq(0, TF, length.out = n+1)
TL<-length(TiempoC)
M_Y=mat.or.vec(M,TL)
Yms=mat.or.vec(Lp,TL)
Wtt <- matrix(0,nrow=M,nb+1)
while (p1<0.05){
################## Generate M Bridges Chaos Wiener expansion
Chaos_bridges <- Gen_Bridges(Xms,a,b,alpha,sigma,n,delta,nb,M,Wtt)
################## Generate M Bridges Chinos (prob de transition)
Chau_method <- Milstein_GBM(a,b,alpha,sigma,n,delta,TiempoC)
################### Generate M Bridges Reversal-time method
Vikingos_method <- M_bridges_MM_GBM(M,a,b,delta,n,alpha,sigma)
###################
obs=501
p1 = ks.test(Chaos_bridges[,obs],Chau_method[,obs])$p.value
p2 = ks.test(Vikingos_method[,obs],Chau_method[,obs])$p.value
p3 = ks.test(Vikingos_method[,obs],Chaos_bridges[,obs])$p.value
print(c(p1,p2,p3))
}
p1=0
while (p1<0.05){
################## Generate M Bridges Chaos Wiener expansion
Chaos_bridges <- Gen_Bridges(Xms,a,b,alpha,sigma,n,delta,nb,M,Wtt)
################## Generate M Bridges Chinos (prob de transition)
Chau_method <- Milstein_GBM(a,b,alpha,sigma,n,delta,TiempoC)
################### Generate M Bridges Reversal-time method
Vikingos_method <- M_bridges_MM_GBM(M,a,b,delta,n,alpha,sigma)
###################
obs=501
p1 = ks.test(Chaos_bridges[,obs],Chau_method[,obs])$p.value
p2 = ks.test(Vikingos_method[,obs],Chau_method[,obs])$p.value
p3 = ks.test(Vikingos_method[,obs],Chaos_bridges[,obs])$p.value
print(c(p1,p2,p3))
}
Data<- rbind(TiempoC,Chaos_bridges)
write.csv(Data,"Chaos_GBM_prob8_a0.2b0.3_alpha0.2_sigma0.3_BM1000.csv")
Data2<- rbind(TiempoC,Chau_method)
write.csv(Data2,"ChauM_GBM_prob8_a0.2b0.3_alpha0.2_sigma0.3_BM1000.csv")
################## Generate M Bridges Chaos Wiener expansion
Chaos_bridges <- Gen_Bridges(Xms,a,b,alpha,sigma,n,delta,nb,M,Wtt)
################## Generate M Bridges Chinos (prob de transition)
Chau_method <- Milstein_GBM(a,b,alpha,sigma,n,delta,TiempoC)
################### Generate M Bridges Reversal-time method
Vikingos_method <- M_bridges_MM_GBM(M,a,b,delta,n,alpha,sigma)
###################
obs=501
p1 = ks.test(Chaos_bridges[,obs],Chau_method[,obs])$p.value
p2 = ks.test(Vikingos_method[,obs],Chau_method[,obs])$p.value
p3 = ks.test(Vikingos_method[,obs],Chaos_bridges[,obs])$p.value
print(c(p1,p2,p3))
Data<- rbind(TiempoC,Chaos_bridges)
write.csv(Data,"Chaos_GBM_prob8_a0.2b0.3_alpha0.2_sigma0.3_BM1000.csv")
Data2<- rbind(TiempoC,Chau_method)
write.csv(Data2,"ChauM_GBM_prob8_a0.2b0.3_alpha0.2_sigma0.3_BM1000.csv")
####### My main
source('Milstein_codes.R')
source('HermiteFunction.R')
source('BridgeChaosFunction.R')
source('IntegralItoTrapecio.R')
source('Vikngos_Geometric.R')
library(ggplot2)
############
sigma=0.3
alpha=0.2
delta=1/1000
n=1000
nb=1000
a=3
b=5
##### number of bridges
M=1000
###### Read propagator D:\DiffusionBridgesWienerExpantion\DiffusionBridgesWienerExpantion\GeometricBrownian\New_propagator
Xms=t(as.matrix(read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/GeometricBrownian/New_propagator/Propagator_order8_int3.0_alpha0.5_sigma1_MB1000.csv'))[,-1])
Lp = dim(Xms)[[1]]
TF=delta*n
TiempoC<-seq(0, TF, length.out = n+1)
TL<-length(TiempoC)
M_Y=mat.or.vec(M,TL)
Yms=mat.or.vec(Lp,TL)
Wtt <- matrix(0,nrow=M,nb+1)
p1=0
