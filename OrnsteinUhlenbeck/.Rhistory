Y1_aux=NULL
Y2x1=NULL
Y2x2=NULL
Y2_aux=NULL
for(i in 1:nb){
X_1<-XmOU1_2dRK(i,n)
X_2<-XmOU2_2dRK(i,n)
Y1_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_1),0)
Y1x1 <-rbind(Y1x1,Y1_aux[1,])
Y1x2 <-rbind(Y1x2,Y1_aux[2,])
Y2_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_2),0)
Y2x1 <-rbind(Y2x1,Y2_aux[1,])
Y2x2 <-rbind(Y2x2,Y2_aux[2,])
}
for (k in 1:10){
print(k)
X1is=rnorm(nb,0,1)
X2is=rnorm(nb,0,1)#fXis(nb,TiempoC)
M_Y1[k,]=apply(Y1x1*X1is[1]*X2is,2,sum)+apply(Y2x1*X2is*X1is[2],2,sum)+Y_0[1,]
M_Y2[k,]=apply(Y1x2*X1is[1]*X2is,2,sum)+apply(Y2x2*X1is[2]*X2is,2,sum)+Y_0[2,]
#M_Y[k,]=Y_0
}
#return(Tiempo,M_Y1)
par(mfrow=c(2,2))
plot(Tiempo,M_Y1[1,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[1,],type = 'l',xlab="t",ylab="Y1_t")
plot(Tiempo,M_Y1[2,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[2,],type = 'l',xlab="t",ylab="Y2_t")
plot(Tiempo,Y1x1[5,])
plot(Tiempo,Y1x1[1,])
plot(Tiempo,Y_0)
plot(Tiempo,Y_0][1,])
plot(Tiempo,Y_0[1,])
plot(Tiempo,Y_0[2,])
####################
####################
XmOU1_2dRK=function(j,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=c(0,0)
for(i in 1:n)
{
RK11 = -(M[1,1]*X[1,i]+M[1,2]*X[2,i]) + sigma11*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf)+sigma12*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK12 = -(M[2,1]*X[1,i]+M[2,2]*X[2,i]) + sigma21*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf)+sigma22*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK21 = -(M[1,1]*(X[1,i]+0.5*delta*RK11)+M[1,2]*(X[2,i]+0.5*delta*RK12)) + sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK22 = -(M[2,1]*(X[1,i]+0.5*delta*RK11)+M[2,2]*(X[2,i]+0.5*delta*RK12)) + sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK31 = -(M[1,1]*(X[1,i]+0.5*delta*RK21)+M[1,2]*(X[2,i]+0.5*delta*RK22)) + sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK32 = -(M[2,1]*(X[1,i]+0.5*delta*RK21)+M[2,2]*(X[2,i]+0.5*delta*RK22)) + sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK41 = -(M[1,1]*(X[1,i]+delta*RK31)+M[1,2]*(X[2,i]+delta*RK32)) +sigma11*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
RK42 = -(M[2,1]*(X[1,i]+delta*RK31)+M[2,2]*(X[1,i]+delta*RK32)) +sigma21*sqrt(2/tf)*sin(1*pi*(Tiempo[i]+delta)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
X[1,i+1] = X[1,i] + (1/6)*delta*(RK11+2*RK21+2*RK31+RK41)
X[2,i+1] = X[2,i] + (1/6)*delta*(RK12+2*RK22+2*RK32+RK42)
}
return(X)
}
XmOU2_2dRK=function(j,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=c(0,0)
for(i in 1:n)
{
RK11 = -(M[1,1]*X[1,i]+M[1,2]*X[2,i]) + sigma11*sqrt(2/tf)*sin(2*pi*Tiempo[i]/tf)+sigma12*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK12 = -(M[2,1]*X[1,i]+M[2,2]*X[2,i]) + sigma21*sqrt(2/tf)*sin(2*pi*Tiempo[i]/tf)+sigma22*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf)
RK21 = -(M[1,1]*(X[1,i]+0.5*delta*RK11)+M[1,2]*(X[2,i]+0.5*delta*RK12)) + sigma11*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK22 = -(M[2,1]*(X[1,i]+0.5*delta*RK11)+M[2,2]*(X[2,i]+0.5*delta*RK12)) + sigma21*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK31 = -(M[1,1]*(X[1,i]+0.5*delta*RK21)+M[1,2]*(X[2,i]+0.5*delta*RK22)) + sigma11*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK32 = -(M[2,1]*(X[1,i]+0.5*delta*RK21)+M[2,2]*(X[2,i]+0.5*delta*RK22)) + sigma21*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta/2)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta/2)/tf)
RK41 = -(M[1,1]*(X[1,i]+delta*RK31)+M[1,2]*(X[2,i]+delta*RK32)) +sigma11*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta)/tf)+sigma12*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
RK42 = -(M[2,1]*(X[1,i]+delta*RK31)+M[2,2]*(X[1,i]+delta*RK32)) +sigma21*sqrt(2/tf)*sin(2*pi*(Tiempo[i]+delta)/tf)+sigma22*sqrt(2/tf)*sin(j*pi*(Tiempo[i]+delta)/tf)
X[1,i+1] = X[1,i] + (1/6)*delta*(RK11+2*RK21+2*RK31+RK41)
X[2,i+1] = X[2,i] + (1/6)*delta*(RK12+2*RK22+2*RK32+RK42)
}
return(X)
}
XmOU1_2dEULER=function(j,n)
{
#tray
X=matrix(0,2,n+1)
X[,1]=c(0,0)
for(i in 1:n)
{
X[1,i+1]=X[1,i]+(-(M[1,1]*X[1,i]+M[1,2]*X[2,i]) + (sigma11+sigma12)*sqrt(2/tf)*sin(1*pi*Tiempo[i]/tf))*delta
X[2,i+1]=X[2,i]+(-(M[2,1]*X[1,i]+M[2,2]*X[2,i]) + (sigma21+sigma22)*sqrt(2/tf)*sin(j*pi*Tiempo[i]/tf))*delta
}
return(X)
}
library("plot3D")
#System conf
n<-1000
nb <-500
t0 <-0
tf <-1
delta <- (tf-t0)/n
Tiempo <-seq(t0, tf, length.out = n+1)
TL<-length(Tiempo)
#initial conditions
x01 <- 0
x02 <- 0
M11 <-1.5
M12 <-1
M21 <-1
M22 <-1.5
sigma11 <-1
sigma12 <-1
sigma21 <-1
sigma22 <-1
theta <- c(1,1)
x0 <- c(x01,x02)
M <- matrix(c(M11,M12,M21,M22),nrow = 2,ncol = 2)
Sigma <- matrix(c(sigma11,sigma12,sigma21,sigma22),nrow = 2,ncol = 2)
M_Y1=mat.or.vec(10,TL)
M_Y2=mat.or.vec(10,TL)
M2_Y1=mat.or.vec(10,TL)
M2_Y2=mat.or.vec(10,TL)
X_0<- OU_2dRK(x0,n)
Y_0<-matrix(0,2,n+1)
int1 <- matrix(0,2,n+1)
int1=cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_0),0)
for(i in 1:TL)
{
Y_0[1,i]= x0[1]+(theta[1]-x0[1])*Tiempo[i]/tf+int1[1,i]
Y_0[2,i]= x0[2]+(theta[2]-x0[2])*Tiempo[i]/tf+int1[2,i]
}
#### propagator for |m|=1
Y1x1=NULL
Y1x2=NULL
Y1_aux=NULL
Y2x1=NULL
Y2x2=NULL
Y2_aux=NULL
for(i in 1:nb){
X_1<-XmOU1_2dRK(i,n)
X_2<-XmOU2_2dRK(i,n)
Y1_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_1),0)
Y1x1 <-rbind(Y1x1,Y1_aux[1,])
Y1x2 <-rbind(Y1x2,Y1_aux[2,])
Y2_aux <- cbind((Tiempo[TL]-Tiempo[1:(TL-1)])*Integrate2d_Xms(1/(tf-Tiempo[-TL]),X_2),0)
Y2x1 <-rbind(Y2x1,Y2_aux[1,])
Y2x2 <-rbind(Y2x2,Y2_aux[2,])
}
for (k in 1:10){
print(k)
X1is=rnorm(nb,0,1)
X2is=rnorm(nb,0,1)#fXis(nb,TiempoC)
M_Y1[k,]=apply(Y1x1*X1is[1]*X2is,2,sum)+apply(Y2x1*X2is*X1is[2],2,sum)+Y_0[1,]
M_Y2[k,]=apply(Y1x2*X1is[1]*X2is,2,sum)+apply(Y2x2*X1is[2]*X2is,2,sum)+Y_0[2,]
#M_Y[k,]=Y_0
}
#return(Tiempo,M_Y1)
par(mfrow=c(2,2))
plot(Tiempo,M_Y1[1,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[1,],type = 'l',xlab="t",ylab="Y1_t")
plot(Tiempo,M_Y1[2,],type = 'l',xlab="t",ylab="X1_t")
plot(Tiempo,M_Y2[2,],type = 'l',xlab="t",ylab="Y2_t")
plot(Tiempo,Y1x1[1,])
plot(Tiempo,Y1x1[2,])
plot(Tiempo,Y1x1[3,])
plot(Tiempo,Y1x1[4,])
plot(Tiempo,Y1x1[100,])
plot(Tiempo,Y1x1[99,])
plot(Tiempo,Y1x1[50,])
Tiempo[TL]-Tiempo[1:(TL-1)]
1/(tf-Tiempo[-TL])
X[,1]=c(0,0)
View(X)
View(X)
plot(X0)
plot(X_0)
X_0
plot(Tiempo,X_0)
plot(Tiempo,X_0[1,])
plot(Tiempo,X_0[2,])
install.packages("languageserver")
setwd("D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck2")
require(stats)
#source('ChaosBridgeFunction.R')
source('Mi_main.R')
source('ExacBridgeFunction.r')
source('Milstein_codes.r')
####OU_bridge####
## Parametros del OU
thetaOU<-0.5
alpha <- thetaOU
sigmaOU<-1.0
sigma <- sigmaOU
delta=1/1000
### Parametros del puente:
a<- 0
b<- 2.0 # test aprobado 0.4
##numero de brownianos
nb=10000
#numero de puentes
M=1000
#numero de puntos por puente
n=1/delta
T0 = 0
TF=delta*n
TiempoC<-seq(T0, TF, length.out = n+1)
TL<-length(TiempoC)
#########
obs=501
p1 =0
p2=0
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
while (p2<0.05){
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
setwd("D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck")
Chaos_OU_00 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chaos_OU_a0b0alpha0.5sigma1.0_BM1000.csv')
Chau_OU_00 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chau_OU_a0b0alpha0.5sigma1.0.csv')
Chaos_OU_01 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chaos_OU_a0b1.0alpha0.5sigma1.0_BM1000.csv')
Chau_OU_01 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chau_OU_a0b1.0alpha0.5sigma1.0.csv')
Chaos_OU_02 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chaos_OU_a0b2.0alpha0.5sigma1.0_BM1000.csv')
Chau_OU_02 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chau_OU_a0b2.0alpha0.5sigma1.0.csv')
Chaos_OU_0.80.5 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chaos_OU_a0.8b0.5alpha0.5sigma1.0_BM1000.csv')
Chau_OU_0.80.5 = read.csv(file ='D:/DiffusionBridgesWienerExpantion/DiffusionBridgesWienerExpantion/OrnsteinUhlenbeck/Chau_OU_a0.8b0.5alpha0.5sigma1.0.csv')
Tiempo = Chaos_OU_00[1,]
Chaos_OU_00 = Chaos_OU_00[2:1001,]
Chau_OU_00 = Chau_OU_00[2:1001,]
Chaos_OU_01 = Chaos_OU_01[2:1001,]
Chau_OU_01 = Chau_OU_01[2:1001,]
Chaos_OU_02 = Chaos_OU_02[2:1001,]
Chau_OU_02 = Chau_OU_02[2:1001,]
Chaos_OU_0.80.5 = Chaos_OU_0.80.5[2:1001,]
Chau_OU_0.80.5 = Chau_OU_0.80.5[2:1001,]
obs=501
p1=ks.test(Chaos_OU_00[,obs],Chau_OU_00[,obs])$p.value
p2=ks.test(Chaos_OU_01[,obs],Chau_OU_01[,obs])$p.value
p3=ks.test(Chaos_OU_02[,obs],Chau_OU_02[,obs])$p.value
p4=ks.test(Chaos_OU_0.80.5[,obs],Chau_OU_0.80.5[,obs])$p.value
print(c(p1,p2,p3,p4))
par(mfrow=c(1,1))
qqplot(Chau_OU_00[,obs],Chaos_OU_00[,obs],ylab="Chau method",xlab="Wiener Chaos approximation method")
abline(0,1)
qqplot(Chau_OU_01[,obs],Chaos_OU_01[,obs],ylab="Chau method",xlab="Wiener Chaos approximation method")
abline(0,1)
qqplot(Chau_OU_02[,obs],Chaos_OU_02[,obs],ylab="Chau method",xlab="Wiener Chaos approximation method")
abline(0,1)
qqplot(Chau_OU_0.80.5[,obs],Chaos_OU_0.80.5[,obs],ylab="Chau method",xlab="Wiener Chaos approximation method")
abline(0,1)
require(stats)
#source('ChaosBridgeFunction.R')
source('Mi_main.R')
source('ExacBridgeFunction.r')
source('Milstein_codes.r')
####OU_bridge####
## Parametros del OU
thetaOU<-0.5
alpha <- thetaOU
sigmaOU<-1.0
sigma <- sigmaOU
delta=1/1000
### Parametros del puente:
a<- 0
b<- 2.0 # test aprobado 0.4
##numero de brownianos
nb=1000
TL<-length(TiempoC)
#########
obs=501
p1 =0
p2=0
require(stats)
#source('ChaosBridgeFunction.R')
source('Mi_main.R')
source('ExacBridgeFunction.r')
source('Milstein_codes.r')
####OU_bridge####
## Parametros del OU
thetaOU<-0.5
alpha <- thetaOU
sigmaOU<-1.0
sigma <- sigmaOU
delta=1/1000
### Parametros del puente:
a<- 0
b<- 2.0 # test aprobado 0.4
##numero de brownianos
nb=1000
#numero de puentes
M=1000
#numero de puntos por puente
n=1/delta
T0 = 0
TF=delta*n
TiempoC<-seq(T0, TF, length.out = n+1)
TL<-length(TiempoC)
#########
obs=501
p1 =0
p2=0
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
while (p2<0.05){
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
while (p2<0.05){
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
while (p2<0.05){
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
require(stats)
#source('ChaosBridgeFunction.R')
source('Mi_main.R')
source('ExacBridgeFunction.r')
source('Milstein_codes.r')
####OU_bridge####
## Parametros del OU
thetaOU<-0.5
alpha <- thetaOU
sigmaOU<-1.0
sigma <- sigmaOU
delta=1/1000
### Parametros del puente:
a<- 0
b<- 2.0 # test aprobado 0.4
##numero de brownianos
nb=100
#numero de puentes
M=1000
while (p2<0.05){
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
##numero de brownianos
nb=1000
#numero de puentes
M=1000
#numero de puntos por puente
n=1/delta
T0 = 0
TF=delta*n
TiempoC<-seq(T0, TF, length.out = n+1)
TL<-length(TiempoC)
#########
obs=501
p1 =0
p2=0
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
while (p2<0.05){
#chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
require(stats)
#source('ChaosBridgeFunction.R')
source('Mi_main.R')
source('ExacBridgeFunction.r')
source('Milstein_codes.r')
####OU_bridge####
## Parametros del OU
thetaOU<-0.5
alpha <- thetaOU
sigmaOU<-1.0
sigma <- sigmaOU
delta=1/1000
### Parametros del puente:
a<- 0
b<- 1.0 # test aprobado 0.4
##numero de brownianos
nb=1000
#numero de puentes
M=1000
#numero de puntos por puente
n=1/delta
T0 = 0
TF=delta*n
TiempoC<-seq(T0, TF, length.out = n+1)
TL<-length(TiempoC)
#########
obs=501
p1 =0
p2=0
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
while (p2<0.05){
#chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
require(stats)
#source('ChaosBridgeFunction.R')
source('Mi_main.R')
source('ExacBridgeFunction.r')
source('Milstein_codes.r')
####OU_bridge####
## Parametros del OU
thetaOU<-0.5
alpha <- thetaOU
sigmaOU<-1.0
sigma <- sigmaOU
delta=1/1000
### Parametros del puente:
a<- 0
b<- 0 # test aprobado 0.4
##numero de brownianos
nb=1000
#numero de puentes
M=1000
#numero de puntos por puente
n=1/delta
T0 = 0
TF=delta*n
TiempoC<-seq(T0, TF, length.out = n+1)
TL<-length(TiempoC)
#########
obs=501
p1 =0
p2=0
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
while (p2<0.05){
#chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
require(stats)
#source('ChaosBridgeFunction.R')
source('Mi_main.R')
source('ExacBridgeFunction.r')
source('Milstein_codes.r')
####OU_bridge####
## Parametros del OU
thetaOU<-0.5
alpha <- thetaOU
sigmaOU<-1.0
sigma <- sigmaOU
delta=1/1000
### Parametros del puente:
a<- 0
b<- 1 # test aprobado 0.4
##numero de brownianos
nb=1000
#numero de puentes
M=1000
#numero de puntos por puente
n=1/delta
T0 = 0
TF=delta*n
TiempoC<-seq(T0, TF, length.out = n+1)
TL<-length(TiempoC)
#########
obs=501
p1 =0
p2=0
chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
while (p2<0.05){
#chaos<- BridgeChaos(a,b,thetaOU,sigmaOU,n,delta,nb,M)
Vikingos_OU = M_bridges_MM_OU(M,a,b,delta,n,thetaOU,sigmaOU)
p2=ks.test(Vikingos_OU[,obs],chaos[,obs])$p.value
print(p2)
par(mfrow=c(1,2))
qqplot(Vikingos_OU[,obs],chaos[,obs],ylab="Vikingos Method",xlab="Wiener Chaos approximation bridge")
abline(0,1)
plot(TiempoC,Vikingos_OU[M/2,],type = 'l',col="red")
lines(TiempoC,chaos[M/2,],type = 'l',col="blue")
}
